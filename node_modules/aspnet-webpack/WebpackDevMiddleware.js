"use strict";
var connect = require('connect');
var webpack = require('webpack');
var url = require('url');
var RequireNewCopy_1 = require('./RequireNewCopy');
function attachWebpackDevMiddleware(app, webpackConfig, enableHotModuleReplacement, enableReactHotModuleReplacement) {
    // Build the final Webpack config based on supplied options
    if (enableHotModuleReplacement) {
        // For this, we only support the key/value config format, not string or string[], since
        // those ones don't clearly indicate what the resulting bundle name will be
        var entryPoints_1 = webpackConfig.entry;
        var isObjectStyleConfig = entryPoints_1
            && typeof entryPoints_1 === 'object'
            && !(entryPoints_1 instanceof Array);
        if (!isObjectStyleConfig) {
            throw new Error('To use HotModuleReplacement, your webpack config must specify an \'entry\' value as a key-value object (e.g., "entry: { main: \'ClientApp/boot-client.ts\' }")');
        }
        // Augment all entry points so they support HMR
        Object.getOwnPropertyNames(entryPoints_1).forEach(function (entryPointName) {
            if (typeof entryPoints_1[entryPointName] === 'string') {
                entryPoints_1[entryPointName] = ['webpack-hot-middleware/client', entryPoints_1[entryPointName]];
            }
            else {
                entryPoints_1[entryPointName].unshift('webpack-hot-middleware/client');
            }
        });
        webpackConfig.plugins = [].concat(webpackConfig.plugins || []); // Be sure not to mutate the original array, as it might be shared
        webpackConfig.plugins.push(new webpack.HotModuleReplacementPlugin());
        // Set up React HMR support if requested. This requires the 'aspnet-webpack-react' package.
        if (enableReactHotModuleReplacement) {
            var aspNetWebpackReactModule = void 0;
            try {
                aspNetWebpackReactModule = require('aspnet-webpack-react');
            }
            catch (ex) {
                throw new Error('ReactHotModuleReplacement failed because of an error while loading \'aspnet-webpack-react\'. Error was: ' + ex.stack);
            }
            aspNetWebpackReactModule.addReactHotModuleReplacementBabelTransform(webpackConfig);
        }
    }
    // Attach Webpack dev middleware and optional 'hot' middleware
    var compiler = webpack(webpackConfig);
    app.use(require('webpack-dev-middleware')(compiler, {
        noInfo: true,
        publicPath: webpackConfig.output.publicPath
    }));
    if (enableHotModuleReplacement) {
        var webpackHotMiddlewareModule = void 0;
        try {
            webpackHotMiddlewareModule = require('webpack-hot-middleware');
        }
        catch (ex) {
            throw new Error('HotModuleReplacement failed because of an error while loading \'webpack-hot-middleware\'. Error was: ' + ex.stack);
        }
        app.use(webpackHotMiddlewareModule(compiler));
    }
}
function beginWebpackWatcher(webpackConfig) {
    var compiler = webpack(webpackConfig);
    compiler.watch({}, function (err, stats) {
        // The default error reporter is fine for now, but could be customized here in the future if desired
    });
}
function createWebpackDevServer(callback, optionsJson) {
    var options = JSON.parse(optionsJson);
    // Read the webpack config's export, and normalize it into the more general 'array of configs' format
    var webpackConfigArray = RequireNewCopy_1.requireNewCopy(options.webpackConfigPath);
    if (!(webpackConfigArray instanceof Array)) {
        webpackConfigArray = [webpackConfigArray];
    }
    var enableHotModuleReplacement = options.suppliedOptions.HotModuleReplacement;
    var enableReactHotModuleReplacement = options.suppliedOptions.ReactHotModuleReplacement;
    if (enableReactHotModuleReplacement && !enableHotModuleReplacement) {
        callback('To use ReactHotModuleReplacement, you must also enable the HotModuleReplacement option.', null);
        return;
    }
    // The default value, 0, means 'choose randomly'
    var suggestedHMRPortOrZero = options.suppliedOptions.HotModuleReplacementServerPort || 0;
    var app = connect();
    var listener = app.listen(suggestedHMRPortOrZero, function () {
        try {
            // For each webpack config that specifies a public path, add webpack dev middleware for it
            var normalizedPublicPaths_1 = [];
            webpackConfigArray.forEach(function (webpackConfig) {
                if (webpackConfig.target === 'node') {
                    // For configs that target Node, it's meaningless to set up an HTTP listener, since
                    // Node isn't going to load those modules over HTTP anyway. It just loads them directly
                    // from disk. So the most relevant thing we can do with such configs is just write
                    // updated builds to disk, just like "webpack --watch".
                    beginWebpackWatcher(webpackConfig);
                }
                else {
                    // For configs that target browsers, we can set up an HTTP listener, and dynamically
                    // modify the config to enable HMR etc. This just requires that we have a publicPath.
                    var publicPath = (webpackConfig.output.publicPath || '').trim();
                    if (!publicPath) {
                        throw new Error('To use the Webpack dev server, you must specify a value for \'publicPath\' on the \'output\' section of your webpack config (for any configuration that targets browsers)');
                    }
                    normalizedPublicPaths_1.push(removeTrailingSlash(publicPath));
                    attachWebpackDevMiddleware(app, webpackConfig, enableHotModuleReplacement, enableReactHotModuleReplacement);
                }
            });
            // Tell the ASP.NET app what addresses we're listening on, so that it can proxy requests here
            callback(null, {
                Port: listener.address().port,
                PublicPaths: normalizedPublicPaths_1,
                // For back-compatibility with older versions of Microsoft.AspNetCore.SpaServices, in the case where
                // you have exactly one webpackConfigArray entry. This will be removed soon.
                PublicPath: normalizedPublicPaths_1[0]
            });
        }
        catch (ex) {
            callback(ex.stack, null);
        }
    });
}
exports.createWebpackDevServer = createWebpackDevServer;
function removeTrailingSlash(str) {
    if (str.lastIndexOf('/') === str.length - 1) {
        str = str.substring(0, str.length - 1);
    }
    return str;
}
function getPath(publicPath) {
    return url.parse(publicPath).path;
}
